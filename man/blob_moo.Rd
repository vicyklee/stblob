% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_moo.R
\name{blob_moo}
\alias{blob_moo}
\title{Multi-objective optimisation (MOO) for spatiotemporal clustering}
\usage{
blob_moo(
  data,
  k,
  r = c(0.5, 1),
  iter = 10,
  run = 100,
  batch = 5,
  converge_ari = 1,
  coords = c(1, 2),
  age = 3,
  space_clustmethod = "kmedoids",
  crs = 4326,
  hull_convex_ratio = 0,
  random_start = FALSE,
  filter_intersects = TRUE,
  filter_clustsize = TRUE,
  max_na = 0.05,
  space_kmat = NULL,
  space_distmat = NULL,
  space_distmethod = NULL,
  w_knn = NULL,
  l_normalise = NULL,
  beta_par = NULL,
  weights = NULL,
  pareto_similar_ari = NULL,
  obj = c("space_wcd", "-time_range_mean", "-time_evenness_mean")
)
}
\arguments{
\item{data}{a data matrix or data frame.}

\item{k}{an integer value or vector of length 2. If a vector is supplied, they specify the lower and upper bounds of the number of clusters.}

\item{r}{a numeric value or vector of length 2. If a vector is supplied, they specify the lower and upper bounds of the relative spatial weight.
They must be \eqn{[0,1]}. Default is c(0.5,1).}

\item{iter}{an integer of the number of iterations. Default is 10.}

\item{run}{an integer of the number of runs. Default is 100.}

\item{batch}{an integer of the number of batches. Default is 5.}

\item{converge_ari}{a numeric value of the Adjusted Rand Index (ARI) that sets the convergence threshold between iterations. It must be \eqn{[0,1]}. Default is 1.}

\item{coords}{a vector of strings or numeric values indicating the columns of coordinates (longitude, latitide). Default is the first two columns.}

\item{age}{a string or numeric value indicating the column of age. Default is the third column.}

\item{space_clustmethod}{a string of the clustering method. Either "kmedoids" or "kkmeans" is available. Default is "kmedoids".}

\item{crs}{a numeric value of the Coordinate Reference System passed on to \code{\link[sf:st_as_sf]{sf::st_as_sf()}}. Default is 4326.}

\item{hull_convex_ratio}{a numeric value controlling the convexity of the hulls passed onto \code{\link[sf:geos_unary]{sf::st_concave_hull()}}. 1 returns convex and 0 maximally concave hulls. Default is 0.5.}

\item{random_start}{a Boolean to randomise starting cluster members. Default is FALSE.}

\item{filter_intersects}{a Boolean to remove an assignment with intersects in space? Default is TRUE.}

\item{filter_clustsize}{a Boolean to assign NA to clusters below the critical size. Default is TRUE.}

\item{max_na}{a numeric value of the maximum proportion of NAs allowed. It must be \eqn{[0,1]}. Default is 0.05.}

\item{space_kmat}{a kernel matrix computed from the spatial distance matrix. Default is NULL.}

\item{space_distmat}{a spatial distance matrix. Default is NULL.}

\item{space_distmethod}{a string of the method, used when \code{space_kmat} and \code{space_distmat} are not specified. Either "geodesic" or "euclidean" is available. Default is "geodesic".}

\item{w_knn}{an integer of the k-th nearest neighbour, used in local scaling for computing the adjacency matrix with \code{\link[=compute_adjacency]{compute_adjacency()}} when \code{space_kmat} is not supplied. Default is 7.}

\item{l_normalise}{a Boolean to normalise the graph Laplacian, passed onto \code{\link[=compute_laplacian]{compute_laplacian()}} when \code{space_kmat} is not supplied. Default is TRUE.}

\item{beta_par}{an numeric initial value for the parameter \eqn{\beta} to be optimised over for the diffusion kernel with \code{\link[=optim_beta]{optim_beta()}} when \code{space_kmat} is not supplied. The range is \eqn{[0.001, \inf]}. Default is 10.}

\item{weights}{a numeric vector of weights for each data point. Default is NULL.}

\item{pareto_similar_ari}{a numeric value of the Adjusted Rand Index (ARI) that
sets the similarity threshold between two Pareto optimal solutions.
It must be \eqn{[0,1]}. Default is NULL.}

\item{obj}{a string vector of objectives. "-" prefix to indicate objectives to be maximised.}
}
\value{
a \code{pop_pareto} object includes a list of the following objects.
\itemize{
\item \code{clust}: a numeric matrix of cluster assignments. Each row is a Pareto optimal solution.
\item \code{summary}: a data frame of summary statistics of all feasible solutions.
\item \code{trace}: a data frame of summary statistics for tracing of all feasible solutions.
\item \code{n_filtered}: a data frame of numbers of filtered solutions.
\item \code{space_kmat_optim_out}: an output of \code{\link[stats:optim]{stats::optim()}} from the optimisation of \eqn{\beta} in \code{\link[=distmat_to_kmat]{distmat_to_kmat()}} when \code{space_kmat} is not supplied.
\item \code{pareto_idx}: a numeric vector of indices of Pareto optimal cluster assignment.
\item \code{obj}: a string vector of objectives.
\item \code{moo_quality}: a data frame of MOO quality indicators.
}
}
\description{
This function populates solutions by weighted sum scalarisation of the bi-objective local search algorithm in \code{\link[=blob_search]{blob_search()}},
optimises multiple objectives under constraints and returns a set of Pareto optimal solutions together with MOO quality indicators.
}
\details{
This function is a wrapper of \code{\link[=blob_populate_batch]{blob_populate_batch()}}, \code{\link[=find_pareto]{find_pareto()}}, \code{\link[=eval_moo]{eval_moo()}} and \code{\link[=find_pareto_similar]{find_pareto_similar()}}.
}
\seealso{
\code{\link[=distmat_to_kmat]{distmat_to_kmat()}}, \code{\link[=blob_populate_batch]{blob_populate_batch()}},
\code{\link[=find_pareto]{find_pareto()}}, \code{\link[=eval_moo]{eval_moo()}}, \code{\link[=find_pareto_similar]{find_pareto_similar()}},
\code{\link[sf:st_as_sf]{sf::st_as_sf()}}, \code{\link[lhs:randomLHS]{lhs::randomLHS()}}, \code{\link[mclust:adjustedRandIndex]{mclust::adjustedRandIndex()}},
\link[future:future]{future::future}, \link[future.apply:future.apply]{future.apply::future.apply},
\code{\link[moocore:nondominated]{moocore::is_nondominated()}}
}
