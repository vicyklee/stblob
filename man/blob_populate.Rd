% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_core.R
\name{blob_populate}
\alias{blob_populate}
\title{Populate solutions by weighted sum scalarisation}
\usage{
blob_populate(
  data,
  k,
  r_range = c(0.5, 1),
  iter = 3L,
  run = 10L,
  space_distmat = NULL,
  space_distmethod = "geodesic",
  iter_method = "iterative",
  converge_ari = NULL,
  random_start = F,
  crs = 4326,
  filter_intersects = T,
  filter_clustsize = T,
  max_na = 0.05,
  ...
)
}
\arguments{
\item{data}{a data matrix or data frame with assigned (starting) clusters as a column.}

\item{k}{an integer of the number of clusters.}

\item{r_range}{a numeric vector of length 2 indicating the lower and upper bounds of the relative spatial weight. They must be \eqn{[0,1]}.}

\item{iter}{an integer of the number of iterations. Default is 3L.}

\item{run}{an integer of the number of runs. Default is 10L.}

\item{space_distmat}{a numeric spatial distance matrix. Default is NULL.}

\item{space_distmethod}{a string of the method for distance computation. It must be either "geodesic" or "euclidean". Default is "geodesic".}

\item{converge_ari}{a numeric value of Adjusted Rand Index (ARI) that sets convergence threshold between two searches. It must be \eqn{[0,1]}. Default is NULL.}

\item{random_start}{a logical operator. Should random start or \code{\link[=start_blobs]{start_blobs()}} be used? Default is F.}

\item{crs}{a numeric value of the Coordinate Reference System passed on to \code{\link[sf:st_as_sf]{sf::st_as_sf()}}. Default is 4326.}

\item{filter_intersects}{a logical operator. Should an assignment with intersects in space be removed? Default is T.}

\item{filter_clustsize}{a logical operator. Should a cluster below a critical size be assigned NA? Default is T.}

\item{max_na}{a numeric value of the maximum proportion of NAs allowed. It must be \eqn{[0,1]}. Default is 0.05.}

\item{...}{these arguments include \code{sigma}.}
}
\value{
a list of the following objects.
\itemize{
\item \code{clust}: a numeric matrix of cluster assignments. Each row is a solution.
\item \code{summary}: a data frame of summary statistics.
\item \code{trace}: a data frame of summary statistics for tracing.
\item \code{n_filtered}: a data frame of numbers of filtered solutions.
}
}
\description{
This function populate solutions by weighted sum scalarisation of the bi-objective function in \code{\link[=blob_search]{blob_search()}} for a given k.
}
\details{
When distances are computed on the fly, kernel method cannot be applied to compute cluster centroids in space.

When \code{space_distmat} is specified. Distance matrix implementation will ignore \code{space_distmethod}.
In that case, kernel method is applied to compute cluster centroids in space.

When the \code{"iterative"} method is specified in \code{iter_method}, one search is performed in every iteration. It runs until the last iteration or convergence.
When \code{converge_ari} is specified, convergence is defined and activated when ARI between the latest and the previous search is
above the specified threshold and at least three iterations are run.

When the \code{"commonality"} method is specified in \code{iter_method}, in every iteration, three searches are run and the shared members are retained for the next iteration.
After the last iteration or when searches converge, the search with the most shared members will be used to assign clusters.
When \code{converge_ari} is specified, convergence is defined and activated when all ARIs between all two pairs of searches is
above the specified threshold and at least three iterations are performed.

The critical size of a cluster is defined as \eqn{\frac{N}{2K}} where \eqn{N} is the number of data point and \eqn{k} is the number of clusters.

Scalarisation is achieved by varying the relative spatial weight generated by Latin hypercube sampling using \code{\link[lhs:randomLHS]{lhs::randomLHS()}}.

To parallelise runs, \code{\link[future.apply:future_lapply]{future.apply::future_lapply()}} is implemented. See \link[future:future]{future::future} and \link[future.apply:future.apply]{future.apply::future.apply} for more information.
}
\seealso{
\code{\link[sf:st_as_sf]{sf::st_as_sf()}}, \code{\link[lhs:randomLHS]{lhs::randomLHS()}}, \code{\link[mclust:adjustedRandIndex]{mclust::adjustedRandIndex()}}, \link[future:future]{future::future}, \link[future.apply:future.apply]{future.apply::future.apply}
}
