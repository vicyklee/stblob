% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_localsearch.R
\name{compute_kmat}
\alias{compute_kmat}
\title{Compute kernel matrix using diffusion kernel from point data}
\usage{
compute_kmat(
  data,
  method = "geodesic",
  k,
  w_knn = 7,
  l_normalise = TRUE,
  beta_par = 10
)
}
\arguments{
\item{data}{a numeric matrix or data frame.}

\item{method}{a string of method. It must be one of "geodesic" or "euclidean". Default is "geodesic".}

\item{k}{an integer of the number of clusters.}

\item{w_knn}{an integer of the k-th nearest neighbour used in local scaling for computing the adjacency matrix, passed onto \code{\link[=compute_adjacency]{compute_adjacency()}}. Default is 7.}

\item{l_normalise}{a Boolean to normalise graph Laplacian, passed onto \code{\link[=compute_laplacian]{compute_laplacian()}}. Default is TRUE.}

\item{beta_par}{an numeric initial value for the parameter \eqn{\beta} to be optimised over for the diffusion kernel, passed onto \code{\link[=optim_beta]{optim_beta()}}. The range is \eqn{[0.001, Inf]}. Default is 10.}
}
\value{
a list of the following objects.
\itemize{
\item \code{kmat}: a diffusion kernel matrix.
\item \code{optim_out}: an output of \code{\link[stats:optim]{stats::optim()}}.
}
}
\description{
This function computes and returns a kernel matrix using a diffusion kernel taking the point data as input.
}
\details{
This function is a wrapper of \code{\link[=compute_distmat]{compute_distmat()}} and \code{\link[=distmat_to_kmat]{distmat_to_kmat()}}. Only geodesic or euclidean distance is available for computing the distances. See \code{\link[=distmat_to_kmat]{distmat_to_kmat()}} for more details.
}
